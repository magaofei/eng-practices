# 小CL



## 为什么要写小CL？ {#为什么}

小而简单的CL是：

 -  **评论更快。**评论者找到五分钟更容易
    多次审查小CL而不是留出30分钟的块
    回顾一个大的CL。
 -  **审查得更彻底。**随着大的变化，审稿人和作者倾向于
    大量的详细评论转移回来感到沮丧
    有时甚至到了重要点被遗漏或掉落的地步。
 -  **不太可能引入错误。**因为你做的更少了，所以
    更容易让您和您的审稿人有效地推断出影响
    CL并查看是否已引入错误。
 -  **如果被拒绝，可以减少浪费。**如果你写了一个巨大的CL然后
    你的评论家说总的方向是错的，你浪费了很多
    工作的。
 -  **更容易合并。**在大型CL上工作需要很长时间，所以你会这样做
    合并时有很多冲突，你必须合并
    经常。
 -  **设计更容易。**更容易完善设计和代码
    健康的一个微小的变化比它精炼所有细节的大
    更改。
 -  **减少对评论的阻碍。**发送自己的部分内容
    整体更改允许您在等待当前时继续编码
    CL在审查中。
 -  **更简单的回滚。**大型CL更有可能触及获得的文件
    在初始CL提交和回滚CL之间更新，这很复杂
    回滚(中间的CL可能需要回滚
    太)。

请注意，**审稿人可以自行决定拒绝您的更改
唯一的原因是它太大了。**通常他们会感谢你的
贡献，但要求你以某种方式使它成为一系列较小的
变化。在你已经完成之后拆分更改可能需要做很多工作
写它，或需要很多时间争论审稿人应该接受的原因
你的巨大变化。首先编写小型CL更容易。

##什么是小？ {} #what_is_small

一般来说，CL的正确大小是**一个自包含的变化**。这意味着
那：

 -  CL做了一个最小的改变，只解决**一件事**。这是
    通常只是一个功能的一部分，而不是一次完整的功能。在
    一般来说，最好是在编写过小的CL时犯错误。
    CL太大了。与您的审稿人合作，找出答案
    可接受的尺寸是。
 - 审稿人需要了解CL的所有内容(未来除外)
    开发)是在CL，CL的描述，现有的代码库，或者
    CL他们已经审查过了。
 - 系统将继续为其用户和开发人员运行良好
    CL签入后。
 -  CL不是那么小，其含义难以理解。如果
    如果添加新API，则应在同一CL中包含API的用法
    审阅者可以更好地了解API的使用方式。这也是
    防止检查未使用的API。

关于有多大“太大”没有严格的规则。 100行是
通常CL的大小合理，1000行通常太大，但是
这取决于你的评论员的判断。更改的文件数
传播也会影响其“规模”。一个文件中的200行更改可能是
好吧，但是分布在50个文件中通常会太大。

请记住，尽管您已经密切参与了您的代码
在你开始编写它的那一刻，审阅者通常没有上下文。什么
看起来像一个可接受的大小的CL你可能会对你的评论家压倒性的。
如有疑问，请编写比您认为需要编写的小的CL。
审稿人很少抱怨获得太小的CL。

## 什么时候大CL好吗？ {#large_okay}

在某些情况下，大的变化并不那么糟糕：

 - 您通常可以将整个文件的删除计为只有一行
    改变，因为审查员不需要很长时间来审查。
 - 有时自动重构工具生成了大型CL
    你完全信任，审稿人的工作只是为了理智
    并说他们确实想要改变。这些CL可以更大，
    虽然上面的一些警告(如合并和测试)仍然存在
    应用。

### 按文件分割{#splitting-files}

分割CL的另一种方法是分组需要的文件
不同的审稿人，但其他自成一体的变化。

例如：您发送一个CL以修改协议缓冲区和
另一个CL用于更改使用该proto的代码。你必须提交
代码CL之前的proto CL，但它们都可以同时进行查看。如果
如果你这样做，你可能想要告知两组评论员关于其他CL的信息
你写的，所以他们有你的更改的上下文。

另一个例子：你发送一个CL用于代码更改而另一个用于代码更改
使用该代码的配置或实验;这更容易回滚
如有必要，也可以将配置/实验文件推送到
生产比代码更改更快。

## 分离出重构{#refactoring}

通常最好在单独的CL中进行重构，而不是进行功能更改或
bug修复。例如，移动和重命名类应该在不同的CL中
修复该类中的错误。审稿人更容易理解
每个CL分开时引入的变化。

修复局部变量名称等小清理可以包含在内部
但是，功能更改或错误修复CL。这取决于开发人员的判断
审核人员决定重构何时进行审核
如果包含在您当前的CL中会更加困难。

## 将相关的测试代码保存在同一个CL {#test_code}中

避免将测试代码拆分为单独的CL。测试验证您的代码
修改应该进入相同的CL，即使它增加了代码行
计数。

但是，<i>独立的</ i>测试修改可以先进入单独的CL，
类似于[重构指南](#重构)。那包括：

*使用新测试验证预先存在的已提交代码。
*重构测试代码(例如引入辅助函数)。
*引入更大的测试框架代码(例如集成测试)。

## 不要破坏构建{#break}

如果你有几个相互依赖的CL，你需要找到一种方法
确保在提交每个CL后整个系统继续工作。除此以外
您可能会在几分钟内打破所有开发人员的构建
您的CL提交之间(如果出现意外错误，甚至更长)
与你后来的CL提交)。

## 不能让它足够小{#cant}

有时你会遇到你的CL *似乎有*的情况
大。这很少是真的。练习编写小型CL的作者可以
几乎总能找到一种将功能分解成一系列小的方法
变化。

在编写大型CL之前，请考虑是否在仅使用重构之前
CL可以为更清洁的实施铺平道路。和你的队友交谈
看看是否有人想过如何在小型CL中实现该功能
代替。

如果所有这些选项都失败了(这应该是非常罕见的)，那么获得同意
从你的评论者提前审查一个大的CL，所以他们被警告
什么即将到来。在这种情况下，期望通过审查过程
很长一段时间，要保持警惕，不要引入错误，并要特别勤奋
关于编写测试。

下一页：[如何处理审稿人评论](handling-comments.md)