＃编写好的CL描述



CL描述是**公开记录** **正在做什么**改变**为什么**
这是刻意制造的。它将成为我们的版本控制历史的永久部分，并且
除了你的评论者之外，还有数百人可能阅读
年份。

未来的开发人员将根据其描述搜索您的CL。有人在
由于对它的微弱记忆，未来可能正在寻找你的改变
相关性，但没有具体方便。如果所有重要信息都是
在代码而不是描述中，对他们来说要困难得多
找到你的CL。

## First Line {#firstline}

*正在做什么的简短摘要。
*完整的句子，写成好像是订单。
*跟随空行。

CL描述的**第一行**应该是一个简短的摘要
*具体* ** CL *正在做什么** *，后面跟一个空白行。
这是大多数未来的代码搜索者在浏览时会看到的内容
版本控制一段代码的历史记录，所以这第一行应该是
足够的信息，他们不必阅读你的CL或其整个描述
只是为了大致了解你的CL实际*做了什么*。

按照传统，CL描述的第一行是一个完整的句子，写成
好像这是一个命令(一个命令性的句子)。例如，说
\“**删除** FizzBu​​zz RPC并**用新系统替换它。”代替
of“**删除** FizzBu​​zz RPC和**用新系统替换它。”
您不必将其余描述写成命令性句子，
虽然。

## Body是信息性的{#informative}

其余描述应该是提供信息的。它可能包括一个简短的
正在解决的问题的描述，以及为什么这是最好的
做法。如果这种方法有任何缺点，它们应该是
提及。如果相关，请包含错误编号等背景信息，
基准测试结果和设计文档的链接。

即使是小型CL也需要注意细节。把CL放在上下文中。

## Bad CL Descriptions {#bad}

“修复bug”是一个不充分的CL描述。什么虫子？你做了什么修复它？
其他类似的不良描述包括：

 - “修复构建”。
 - “添加补丁”。
 - “将代码从A移动到B.”
-   “阶段1。”
 - “添加便利功能。”
 - “杀死奇怪的网址。”

其中一些是真正的CL描述。他们的作者可能相信他们是
提供有用的信息，但它们不符合CL的目的
描述。

##好的CL描述{#good}

以下是一些很好的描述示例。

###功能改变

> rpc：删除RPC服务器消息freelist上的大小限制。
>
>像FizzBu​​zz这样的服务器有非常大的消息，并且可以从重用中受益。
>使自由列表更大，并添加一个释放freelist条目的goroutine
>慢慢地，随着时间的推移，空闲服务器最终释放所有空闲列表
>条目。

前几个词描述了CL实际上做了什么。剩下的
描述谈到正在解决的问题，为什么这是一个很好的解决方案，
以及有关具体实施的更多信息。

###重构

>使用TimeKeeper构造任务以使用其TimeStr和Now方法。
>
>向Task添加一个Now方法，因此可以删除borglet()getter方法(其中
>仅被OOMCandidate用来调用borglet的Now方法)。这取代了
> Borglet上委托给TimeKeeper的方法。
>
>允许任务提供现在是消除依赖性的一个步骤
> Borglet。最终，合作者依赖于从任务中获取“现在”
>应该更改为直接使用TimeKeeper，但这是一个
>以小步骤进行重构的住宿。
>
>继续重构Borglet层次结构的长期目标。

第一行描述了CL的作用以及它是如何改变的
过去。其余的描述讨论了具体的实现，
CL的背景，解决方案并不理想，未来可能的方向。
它还解释了*为什么*正在进行此更改。

### 小CL需要一些上下文

>为status.py创建Python3构建规则。
>
>这使得已经在Python3中使用它的消费者依赖于
>原始状态构建规则旁边的规则，而不是其中的某个位置
>他们自己的树。如果可以，它鼓励新消费者使用Python3，
>而不是Python2，并显着简化了一些自动构建文件
>目前正在进行的重构工具。

第一句话描述了实际做了什么。剩下的
说明解释*为什么*正在进行更改并为审阅者提供了很多帮助
上下文。

## 在提交CL之前查看说明

CL在审核期间可能会发生重大变化。值得回顾一下
提交CL之前的CL描述，以确保描述仍然存在
反映了CL的作用。

下一页：[小CL](small-cls.md)